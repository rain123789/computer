时间复杂度O(n log n)的排序算法有哪些？
A. 冒泡排序、选择排序
B. 快速排序、归并排序、堆排序
C. 计数排序、桶排序
D. 插入排序、希尔排序
答案: B
解析: 快速排序、归并排序和堆排序的平均时间复杂度都是O(n log n)，它们是较为高效的比较排序算法。

动态规划的核心思想是什么？
A. 分治法
B. 贪心算法
C. 最优子结构和重叠子问题
D. 回溯法
答案: C
解析: 动态规划的核心思想是利用问题的最优子结构和重叠子问题特性，将问题分解为子问题并存储子问题的解以避免重复计算。

二分查找的时间复杂度是多少？
A. O(n)
B. O(n log n)
C. O(log n)
D. O(1)
答案: C
解析: 二分查找在有序数组中查找元素的时间复杂度是O(log n)，每次比较后将搜索范围缩小一半。

广度优先搜索(BFS)和深度优先搜索(DFS)的主要区别是什么？
A. BFS使用队列，DFS使用栈
B. BFS只适用于树结构，DFS适用于所有图
C. BFS找到的一定是最短路径，DFS不一定
D. BFS时间复杂度更低
答案: A
解析: BFS通常使用队列实现，按层次遍历；DFS通常使用栈(或递归)实现，尽可能深地探索分支。在找最短路径时，BFS更合适。

什么是贪心算法？
A. 一种总是选择当前看起来最优解的算法
B. 一种穷举所有可能解的算法
C. 一种通过概率模型求解的算法
D. 一种只适用于排序问题的算法
答案: A
解析: 贪心算法是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是全局最优的算法策略。

最小生成树的两种常用算法是什么？
A. Dijkstra算法和Floyd算法
B. Kruskal算法和Prim算法
C. Bellman-Ford算法和A*算法
D. 快速排序和归并排序
答案: B
解析: Kruskal算法和Prim算法是求解无向图最小生成树的两种经典算法，前者基于边的权重排序，后者基于顶点扩展。

斐波那契数列的时间复杂度是多少？（朴素递归实现）
A. O(n)
B. O(n²)
C. O(log n)
D. O(2^n)
答案: D
解析: 朴素递归实现的斐波那契数列时间复杂度是O(2^n)，因为每计算一个数会产生两个递归调用，形成二叉树结构。

HashMap的查找操作平均时间复杂度是多少？
A. O(n)
B. O(log n)
C. O(1)
D. O(n log n)
答案: C
解析: HashMap通过哈希函数将键映射到桶中，理想情况下查找操作的平均时间复杂度是O(1)，但存在哈希冲突时可能退化。

什么是分治算法？
A. 一种将问题分解为相互独立子问题的算法
B. 一种解决动态规划问题的算法
C. 一种只用于图论的算法
D. 一种解决NP完全问题的算法
答案: A
解析: 分治算法的基本思想是将一个复杂问题分解成若干个相同或相似的子问题，解决子问题，然后合并子问题的解得到原问题的解。

计算最短路径常用的算法是什么？
A. Kruskal和Prim算法
B. Dijkstra和Floyd-Warshall算法
C. 快速排序和归并排序
D. BFS和A*算法
答案: B
解析: Dijkstra算法用于计算单源最短路径，适用于无负权边图；Floyd-Warshall算法用于计算所有点对之间的最短路径。 